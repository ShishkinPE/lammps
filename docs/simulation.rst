Simulation
==============

When using pylion, molecular dynamics simulations are offloaded from python to
LAMMPS.
Simulations are configured by appending parameters on a ``Simulation`` object that once setup and executed, generates an input file that is used by a LAMMPS subprocess.
An asynchronous update loop monitors the progress of the subprocess, allowing error interception and diagnostic updates.
Once complete (or on user interrupt) pylion terminates the LAMMPS subprocess is terminated and reverts control to you so you can analyse the generated data.

.. module:: pylion

Simulation object
-----------------

At the heart of pylion is the ``Simulation`` class.
It is implemented as a subclass of ``list`` so it provides a familiar API.


.. autoclass:: Simulation
  :members:
  :special-members: __contains__

  ``Simulation`` is for all practical purposes a list that only contains python dictionaries; appending any other type will raise an error.
  During its lifetime it will do the following:

  - check the various configuration parameters, fixes, and commands as you append them.
  - generate a ``simulation.lammps`` file using a jinja2 template.
  - call the ``lammps`` subprocess with said file and deal with output piping and signal handling.
  - generate an h5 file with all the necessary parameters needed to rerun the simulation.

  The same simulation will not run again if it has executed already.
  This keeps the simulations atomic and you can be sure that one h5 file correponds to one simulation.

  ``Simulation`` also keeps track of the unique ids of the appended dictionaries.
  All simulation items are identified through a ``uid`` if they have one, otherwise it defaults to ``None``.
  To search, index, or remove an item it needs to have a ``uid``.

  .. warning::
    Not all list methods are overridden or needed. Only the ones referenced here.



Attributes
----------

The simulation attributes are implemented as a simple subclass of ``dict`` that adds two methods to ``save`` and ``load`` the dictionary items to an h5 file. ``save`` first serialises the dict values as json strings so that they can be saved as h5 attributes. ``loads`` deserialises the json and returns proper python objects so you never know what happened.

A ``Simulation()`` defines a set of default attributes that control simulation parameters:

- *executable*, <path-to-lammps-binary>
- *timestep*, the equations of motion are propagated by this much at every step.
  You can set this parameter to whatever value you want but ideally it would be faster than the fastest timescale in your problem (usually the rf frequency of the Paul trap).
  Any fix can also set the timestep automatically if it has a ``timestep`` key in its dictionary, whose value is less than the current value of the simulation timestep.
- *domain*, defines the lower limits of the spatial region of the simulation.
  The simulation box may expand beyond these initial limits, but all ions must be initially placed within this region or an error will be thrown by lammps.
  Check out the lammps documentation for the `boundary <http://lammps.sandia.gov/doc/boundary.html>`_ and `box <http://lammps.sandia.gov/doc/create_box.html>`_ commands for more information.

  A guideline for optimisation is to ensure the simulation domain fits the
  enclosed atoms tightly; this ensures that when the domain is spatially
  partitioned there are an approximately equal number of ions per processor.
  When reducing the simulation box, lammps raises the following error::

      Cannot use neighbor bins - box size << cutoff

- *name*, slugified name of the simulation. Also used for the h5 file.
- *neighbour*, skin and list.
  Check out the `neighbour <http://lammps.sandia.gov/doc/neighbor.html>`_ command and the ``nsq`` style to build neighbour lists.
  This is the default style used in pylion although its scaling is proportional to number of ions per processor squared.
- *coulombcutoff*, the range of the Coulomb interaction defaults to 10cm.
  You can reduce the neighbour skin size or the Coulomb cutoff to increase the simulation speed, but this may result in unphysical ion-ion interactions.
- *template*, the jinja2 template used.
- *version*, the pylion version.
- *rigid*, groups that are tagged as rigid.
  This is autogenerated by ion dictionaries that have the key ``rigid``.
  Defaults to a single element ``exists = False``.

At execution time the following attributes are also set:

- *time*, the time the simulation was started.
- *output_files*, names of the files used by ``dump`` commands to save the simulation output.

.. warning::
  Make sure you know what you are doing if you overwrite the defaults.

You can add literally anything to the above using dict notation.
Use it to add notes about the simulation, keep track of other parameters or anything you think belongs to the generated h5 file.

.. PUT THESE IN EXTENSNIONS SO THE USER NEEDS TO KNOW LAMMPS CONCEPTS
.. To output data from a pyLIon simulation the `dump` function is used. This allows
.. the user to specify which properties of an ion should be output every
.. `nsteps` frames, where nsteps is an input argument to the `dump` function. A list,
.. whose elements are properties to be output by the `dump` command, are passed as
.. the second input argument to `dump`. A list of valid properties is:
..
.. ==== ===== ==================
.. Name Type  Description
.. ==== ===== ==================
.. id   int   identifier of an individual atom
.. type int   atom species identifier
.. x    float x-coordinate of atom
.. y    float y-coordinate of atom
.. z    float z-coordinate of atom
.. vx   float x-velocity of atom
.. vy   float y-velocity of atom
.. vz   float z-velocity of atom
.. mass float mass of atom
.. q    float atomic charge of atom
.. ==== ===== ==================
..
.. In `LAMMPS` parlance this implements the
.. `dump <http://lammps.sandia.gov/doc/dump.html>`_ custom style. The `id`
.. property of the atoms is output bu default. As warned in the reference
.. above, the order of atoms in the output file may change due to spatial
.. sorting and/or multiple processor domains; it is thus advised to output `id` in
.. addition to any other properties so that individual atomic trajectories may be
.. faithfully recomposed.
..
.. The `dump` function returns a `LAMMPSRunCommand` object which should be added to
.. the simulation. As with all `LAMMPSRunCommand` objects, the output of `dump` is
.. sensitive to when it is added to the experiment. In combination with the
.. `sim.unfix` command, this allows the user to add and remove different dumps for
.. different stages of a simulation. For example, to only generate output for the
.. evolution of the system after a minimisation routine::
..
..    # Do minimisation here
..    ...
..    sim.runcommand = lmp.dump('positions.txt', ['x', 'y', 'z'], 100)
..
..    # Do evolution here
..    ...
..    sim.unfix(sim.runcommand[idx])
..
.. where `idx` is the index of the dump runcommand.
..
.. Multiple concurrent output files are supported. To use this feature, create
.. different dump objects as above and add them to the simulation object. For
.. example, to output coordinates and velocities to separate files::
..
..    sim.runcommand = lmp.dump('positions.txt', ['x', 'y', 'z'], 10)
..    sim.runcommand = lmp.dump('velocities.txt', ['vx', 'vy', 'vz'], 100)
..
.. Time integration
.. ^^^^^^^^^^^^^^^^
..
.. For faster data analysis it is advisable to keep output files small. This has
.. the obvious advantages of lower RAM usage and faster computation. Often in MD
.. simulations of ion traps a time-averaged quantity is of interest; for
.. example, by averaging atomic velocities over a radiofrequency period secular
.. velocities can be defined, from which a secular temperature may be determined
.. that excludes the micromotion contribution.
..
.. Time-averaging in LIon may be achieved using the timeAvg function. The first
.. argument to this function is a cell array of properties to time average; the
.. second argument is the time period to average over. The output of this
.. function, a list of LAMMPSVariable objects, is passed as an input argument to
.. dump, and has a defined result at the final timestep of every averaging
.. window. As an example, to implement the previously discussed secular velocity
.. for a given radiofrequency (RF) trap::
..
..    sim.runcommand = lmp.dump('positions.txt', lmp.lammpsaverage(['vx', 'vy', 'vz'], 1/RF, 5)
..
.. **I think this is obsolete. Check new averaging**
..
.. Loading Data for analysis
.. -------------------------
..
.. The function ``readdump(file)`` is provided to allow loading of output data from
.. `lammps` into Python, where file is a data file generated using dump. A
.. necessary requirement of this function is that `id` was specified as the first
.. property to output via `dump`.
..
.. When using `readdump` the number of output arguments must match the number of
.. properties present in the data file. If this is not the case, an error is
.. returned explaining that the dump file is incompatible with the specified
.. output format. For compatible files, the output arguments are populated with
.. the data for each atom and `timestep` in the file. For example, to read the
.. dump file generated by a previously defined object::
..
..    output = lmp.readdump('positions.txt')
..
..    # change to numpy arrays for postprocessing
..    for key in ['x', 'y', 'z']:
..        output[key] = np.array(output[key])
