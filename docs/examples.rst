Examples
========

A number of example scripts can be found in the Examples folder of the
distribution.

Single species pseudopotential
------------------------------

First we import pyLIon along with numpy and `matplotlib` for postprocessing::

    import pyLIon.lammps as lmp
    import matplotlib.pyplot as plt
    import numpy as np

Next, we configure the simulation domain for the ions. This defines the
minimum lower limit to the spatial region which will be simulated. The
simulation box may expand beyond these initial limits, but all atoms must be
initially placed within this region or an error will be thrown by `LAMMPS`. More
information may be found in the documentation for the `LAMMPS`
`boundary <http://lammps.sandia.gov/doc/boundary.html>`_ and
`box <http://lammps.sandia.gov/doc/create_box.html>`_ commands.

A guideline for optimisation is to ensure the simulation domain fits the
enclosed atoms tightly; this ensures that when the domain is spatially
partitioned there are an approximately equal number of atoms per processor.
When reducing the simulation box, the following error may be observed::

    Cannot use neighbor bins - box size << cutoff

As discussed in the documentation on the
`neighbour <http://lammps.sandia.gov/doc/neighbor.html>`_ command a
solution is to use the nsq style to build neighbour lists; however, this
comes with a caveat of worse scaling (proportional to number of atoms per
processor squared). Alternatively, the neighbour skin size or the Coulomb
repulsion cutoff may be reduced, but this action may result in ion-ion
repulsion not spanning the full length of the Coulomb crystal.

To set the initial simulation domain::

    sim.simulationbox = lmp.Domain(1e-3, 1e-3, 1e-3)

Next we add some atoms. First we define a new atom type, specifying the charge
and mass of the ion. Then we create a few randomly positioned ions::

    radiusofcloud = 1e-3
    charge = -1
    mass = 30
    number = 10
    ions = lmp.AtomProperties(charge, mass)
    sim.atoms = lmp.createioncloud(radiusofcloud, ions, number)

We add a trap after defining all the relevant parameters::

    trap = lmp.Trap(300, -0.01, 5.5e-3, 7e-3, 0.244, 3.85e6, 1, [0, 0], True)
    sim.fix = lmp.linearpaultrap(trap, sim.atoms[0])

Since tha last argument is True, the pseudopotential approximation is used and
the secular frequencies are calculated automatically. We are only interested
in minimising the energy of the ions and output their position while doing so::

    sim.runcommand = lmp.dump('positions.txt', ['x', 'y', 'z'], 100)
    sim.runcommand = lmp.minimise(1.4e-26, 0, 100000, 100000, 1e-7)

and begin the execution::

    sim.execute()

To finish the example, we read the atomic trajectories generated by the
simulation (stored in `positions.txt`) and plot a graph of the data::

    output = lmp.readdump('positions.txt')

    # change to numpy arrays for postprocessing
    for key in ['x', 'y', 'z']:
        output[key] = np.array(output[key])

    plt.plot(output['x']*1e6, output['z']*1e3)
    plt.plot(output['x'][-1]*1e6, output['z'][-1]*1e3, 'o')
    plt.xlabel('x position ($\mu m$)')
    plt.ylabel('z position ($mm$)')
    plt.show()

.. image:: _static/figure_1.png
   :width: 800 px
   :height: 600px
   :scale: 50 %

Single species RF trap
----------------------

This example begins with similar definitions to the previous one but instead
of randomly positioned ions we place 3 ions at predefined positions::

    charge = -1
    mass = 30
    ions = lmp.AtomProperties(charge, mass)
    sim.atoms = lmp.placeatoms(lmp.Position([0, 0, 0], [0, 0, 0], [-1e-4, 0, 1e-4]), ions)

We then add a paul trap::

    trap = lmp.Trap(300, -0.01, 5.5e-3, 7e-3, 0.244, 3.85e6, 1, [0, 0], False)
    sim.fix = lmp.linearpaultrap(trap, sim.atoms[0])

where now the full RF simulation is used. To cool the translational motion of
the ions, we attach a Langevin bath; this exponentially lowers the temperature
of the ensemble to 3 mK by applying a viscous damping force (with a relaxation
time of 10 mus and a random kick each timestep::

    sim.fix = lmp.langevinbath(3e-4, 1e-5)

We configure pyLIon to evolve the dynamics for 10000 timesteps::

    sim.runcommand = lmp.runcommand(10000)
    sim.execute()

Analysis of the results proceeds as above::

    output = lmp.readdump('positions.txt')

    # change to numpy arrays for postprocessing
    for key in ['x', 'y', 'z']:
        output[key] = np.array(output[key])

    plt.plot(output['x']*1e6, output['z']*1e3)
    plt.plot(output['x'][-1]*1e6, output['z'][-1]*1e3, 'o')
    plt.xlabel('x position ($\mu m$)')
    plt.ylabel('z position ($mm$)')
    plt.show()

.. image:: _static/figure_2.png
   :width: 800 px
   :height: 600px
   :scale: 50 %